name: Terraform & Ansible CI/CD

on:
  push:
    branches:
      - pre-prod
    paths:
      - 'terraform/envs/**'
      - 'terraform/modules/**'
      - 'ansible/**'
      - 'flaskapp-database/**'
      - 'k8s/**'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:

jobs:
  terraform:
    name: Terraform & Ansible
    runs-on: ubuntu-latest
    


    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible and kubectl
        run: |
          python -m pip install --upgrade pip
          pip install ansible boto3
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Create S3 Backend Bucket
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="poc-prod-vpc-logs-${ACCOUNT_ID}-preprod"
          echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

          aws s3api head-bucket --bucket $BUCKET_NAME --region eu-west-1 2>/dev/null || {
            echo "Creating S3 bucket: $BUCKET_NAME"
            aws s3api create-bucket \
              --bucket $BUCKET_NAME \
              --region eu-west-1 \
              --create-bucket-configuration LocationConstraint=eu-west-1
            aws s3api put-bucket-versioning \
              --bucket $BUCKET_NAME \
              --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption \
              --bucket $BUCKET_NAME \
              --server-side-encryption-configuration '{
                "Rules": [
                  { "ApplyServerSideEncryptionByDefault": { "SSEAlgorithm": "AES256" } }
                ]
              }'
          }

      - name: Set Environment Path
        run: echo "TF_DIR=terraform/envs/pre-prod" >> $GITHUB_ENV

      - name: Terraform Init
        run: terraform -chdir=$TF_DIR init

      - name: Terraform Validate
        run: terraform -chdir=$TF_DIR validate

      - name: Terraform Plan
        run: terraform -chdir=$TF_DIR plan -out=tfplan

      - name: Terraform Apply
        id: apply
        run: terraform -chdir=$TF_DIR apply -auto-approve tfplan
        continue-on-error: true

      - name: Handle Terraform Failure
        if: steps.apply.outcome == 'failure'
        run: |
          echo "Terraform apply failed. Attempting rollback..."
          terraform -chdir=$TF_DIR destroy -auto-approve
          exit 1

      - name: Capture Terraform Outputs
        id: tf_outputs
        run: |
          terraform -chdir=$TF_DIR output -json > terraform_outputs.json
          CONTROL_PLANE_IP=$(jq -r '.ec2_public_ips.value[0]' terraform_outputs.json)
          WORKER_IP=$(jq -r '.ec2_public_ips.value[1]' terraform_outputs.json)
          CONTROL_PLANE_PRIVATE_IP=$(jq -r '.ec2_private_ips.value[0]' terraform_outputs.json)
          WORKER_PRIVATE_IP=$(jq -r '.ec2_private_ips.value[1]' terraform_outputs.json)
          ECR_REPOSITORY_URL=$(jq -r '.ecr_repository_url.value' terraform_outputs.json)

          echo "CONTROL_PLANE_IP=$CONTROL_PLANE_IP" >> $GITHUB_ENV
          echo "WORKER_IP=$WORKER_IP" >> $GITHUB_ENV
          echo "CONTROL_PLANE_PRIVATE_IP=$CONTROL_PLANE_PRIVATE_IP" >> $GITHUB_ENV
          echo "WORKER_PRIVATE_IP=$WORKER_PRIVATE_IP" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_URL=$ECR_REPOSITORY_URL" >> $GITHUB_ENV

          echo "control_plane_ip=$CONTROL_PLANE_IP" >> $GITHUB_OUTPUT
          echo "worker_ip=$WORKER_IP" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$ECR_REPOSITORY_URL" >> $GITHUB_OUTPUT

      - name: Copy Terraform SSH Private Key
        run: |
          cp terraform/modules/compute/poc-pre-prod-key.pem private-key.pem
          cp terraform/modules/compute/poc-pre-prod-key.pem ansible/poc-pre-prod-key.pem
          chmod 600 private-key.pem ansible/poc-pre-prod-key.pem

      - name: Generate Ansible Inventory
        run: |
          cd ansible
          cat > inventory.yml << EOF
          all:
            children:
              controlplane:
                hosts:
                  cp1:
                    ansible_host: ${{ env.CONTROL_PLANE_IP }}
                    ansible_user: ubuntu
                    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
                    private_ip: ${{ env.CONTROL_PLANE_PRIVATE_IP }}
              worker:
                hosts:
                  worker1:
                    ansible_host: ${{ env.WORKER_IP }}
                    ansible_user: ubuntu
                    ansible_ssh_common_args: '-o StrictHostKeyChecking=no'
                    private_ip: ${{ env.WORKER_PRIVATE_IP }}
                    control_plane_private_ip: ${{ env.CONTROL_PLANE_PRIVATE_IP }}
          EOF
          cat inventory.yml

      - name: Wait for SSH to be available
        run: |
          echo "Waiting for SSH to be available on instances..."
          sleep 60
          until ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i private-key.pem ubuntu@${{ env.CONTROL_PLANE_IP }} 'echo SSH ready'; do
            echo "Waiting for control plane SSH..."
            sleep 30
          done
          until ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no -i private-key.pem ubuntu@${{ env.WORKER_IP }} 'echo SSH ready'; do
            echo "Waiting for worker SSH..."
            sleep 30
          done

      - name: Run Ansible Playbook
        run: |
          export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          ansible-playbook -i ansible/inventory.yml ansible/playbook.yml --private-key ansible/poc-pre-prod-key.pem -vv
  
    outputs:
      ecr_repository_url: ${{ steps.tf_outputs.outputs.ecr_repository_url }}
      control_plane_ip: ${{ steps.tf_outputs.outputs.control_plane_ip }}
      worker_ip: ${{ steps.tf_outputs.outputs.worker_ip }}
      control_plane_private_ip: ${{ steps.tf_outputs.outputs.control_plane_private_ip }}
      worker_private_ip: ${{ steps.tf_outputs.outputs.worker_private_ip }}
      ssh_private_key: ${{ steps.tf_outputs.outputs.private_key_path }}
      
  deploy:
    name: Build and Deploy Flask App to ECR
    runs-on: ubuntu-latest
    needs: terraform

    env:
      AWS_REGION: eu-west-1
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Flask Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./flaskapp-database/flaskapp
          push: true
          tags: |
            ${{ needs.terraform.outputs.ecr_repository_url }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push MySQL Docker image  
        uses: docker/build-push-action@v5
        with:
          context: ./flaskapp-database/mysql
          push: true
          tags: |
            ${{ needs.terraform.outputs.ecr_repository_url }}:mysql-${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          

      - name: Display ECR Repository Information
        run: |
          echo "=== ECR DEPLOYMENT SUMMARY ==="
          echo "ECR Repository: ${{ needs.terraform.outputs.ecr_repository_url }}"
          echo "Flask Image: ${{ needs.terraform.outputs.ecr_repository_url }}:${{ env.IMAGE_TAG }}"
          echo "MySQL Image: ${{ needs.terraform.outputs.ecr_repository_url }}-mysql:${{ env.IMAGE_TAG }}"
          echo "Image Tag: ${{ env.IMAGE_TAG }}"
          echo ""
          echo "=== NEXT STEPS ==="
          echo "Images are now available in ECR and ready for Kubernetes deployment"
      
      
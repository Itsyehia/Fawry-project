name: CI Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read

env:
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain

jobs:

  # 1) Run tests and coverage reporting
  test_and_coverage:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          set -x
          python -m pip install --upgrade pip
          pip install -r flaskapp-database/flaskapp/requirements.txt
          pip install pytest pytest-cov

      - name: Run pytest with coverage
        run: |
          cd flaskapp-database/flaskapp
          PYTHONPATH=. pytest -v --cov=app --cov-report=xml --cov-report=html

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: flaskapp-database/flaskapp/htmlcov
  
  # 2) Run linting with flake8
  flake8:
    runs-on: ubuntu-latest
    needs: test_and_coverage
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install flake8
        run: |
          set -x
          python -m pip install --upgrade pip
          pip install flake8

      - name: Run flake8
        run: flake8 . --show-source --statistics

  # 3) Run secret detection with gitleaks
  gitleaks: 
    runs-on: ubuntu-latest
    needs: flake8
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        with:
          args: detect --source . --no-git --redact --exit-code 1
        continue-on-error: true

  # 4) Run CodeQL security analysis
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    needs: gitleaks
    permissions:
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # 5) Build and push images to Docker Hub (flaskapp + mysql)
  build_and_push:
    runs-on: ubuntu-latest
    needs: codeql
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Docker login
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build & push flaskapp image
        uses: docker/build-push-action@v4
        with:
          context: ./flaskapp-database/flaskapp
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/flaskapp:latest
          provenance: false
          no-cache: true
          outputs: type=registry
          build-args: |
            BUILDKIT_PROGRESS=plain

      - name: Build & push mysql image
        uses: docker/build-push-action@v4
        with:
          context: ./flaskapp-database/mysql
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/mysql:latest
          provenance: false
          no-cache: true
          outputs: type=registry
          build-args: |
            BUILDKIT_PROGRESS=plain

  # 6) Run Trivy vulnerability scan
  trivy_scan:
    runs-on: ubuntu-latest
    needs: build_and_push
    steps:
      - name: Install Trivy
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin latest

      - name: Scan flaskapp image
        run: |
          trivy image --no-progress --format json --output trivy-flaskapp-report.json ${{ secrets.DOCKER_USERNAME }}/flaskapp:latest

      - name: Scan mysql image
        run: |
          trivy image --no-progress --format json --output trivy-mysql-report.json ${{ secrets.DOCKER_USERNAME }}/mysql:latest

      - name: Upload Trivy Reports
        uses: actions/upload-artifact@v4
        with:
          name: trivy-reports
          path: |
            trivy-flaskapp-report.json
            trivy-mysql-report.json

    # 7) Deploy to K3s cluster
  deploy_to_k8s:
    runs-on: ubuntu-latest
    needs: trivy_scan
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install AWS CLI and kubectl
        run: |
          python -m pip install --upgrade pip
          pip install awscli
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Get Terraform outputs from S3 state
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET_NAME="poc-prod-vpc-logs-${ACCOUNT_ID}-preprod"
          
          echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

          # Download terraform state
          aws s3 cp s3://$BUCKET_NAME/pre-prod/terraform.tfstate terraform_outputs.json
          
          # Install jq for JSON parsing
          sudo apt-get update && sudo apt-get install -y jq

          CONTROL_PLANE_IP=$(jq -r '.outputs.ec2_public_ips.value[0]' terraform_outputs.json)
          WORKER_IP=$(jq -r '.outputs.ec2_public_ips.value[1]' terraform_outputs.json)
          CONTROL_PLANE_PRIVATE_IP=$(jq -r '.outputs.ec2_private_ips.value[0]' terraform_outputs.json)
          WORKER_PRIVATE_IP=$(jq -r '.outputs.ec2_private_ips.value[1]' terraform_outputs.json)
          SSH_PRIVATE_KEY=$(jq -r '.outputs.ssh_private_key.value' terraform_outputs.json)

          echo "CONTROL_PLANE_IP=$CONTROL_PLANE_IP" >> $GITHUB_ENV
          echo "WORKER_IP=$WORKER_IP" >> $GITHUB_ENV
          echo "CONTROL_PLANE_PRIVATE_IP=$CONTROL_PLANE_PRIVATE_IP" >> $GITHUB_ENV
          echo "WORKER_PRIVATE_IP=$WORKER_PRIVATE_IP" >> $GITHUB_ENV

          echo "Control Plane IP: $CONTROL_PLANE_IP"
          echo "Worker IP: $WORKER_IP"

          # Save SSH private key
          echo "$SSH_PRIVATE_KEY" > private-key.pem
          chmod 600 private-key.pem

      - name: Setup SSH access to K3s
        run: |
          mkdir -p ~/.ssh
          cp private-key.pem ~/.ssh/k3s-key
          chmod 600 ~/.ssh/k3s-key

          # Write SSH config
          cat > ~/.ssh/config <<EOF
          Host k3s-control
            HostName ${{ env.CONTROL_PLANE_IP }}
            User ubuntu
            IdentityFile ~/.ssh/k3s-key
            StrictHostKeyChecking no
          EOF

          echo "âœ… SSH config written:"
          cat ~/.ssh/config

      - name: Debug SSH Info
        run: |
          echo "Control plane IP: ${{ env.CONTROL_PLANE_IP }}"
          ls -l ~/.ssh/
          cat ~/.ssh/config

      - name: Copy kubeconfig from K3s
        run: |
          mkdir -p ~/.kube
          ssh k3s-control "sudo cat /etc/rancher/k3s/k3s.yaml" > ~/.kube/config
          echo "Original kubeconfig:"
          cat ~/.kube/config
          sed -i "s/127.0.0.1/${{ env.CONTROL_PLANE_IP }}/g" ~/.kube/config
          sed -i "s/localhost/${{ env.CONTROL_PLANE_IP }}/g" ~/.kube/config
          sed -i "s/${{ env.CONTROL_PLANE_PRIVATE_IP }}/${{ env.CONTROL_PLANE_IP }}/g" ~/.kube/config
          echo "Updated kubeconfig:"
          cat ~/.kube/config

      - name: Wait for kubectl to connect to K3s
        run: |
          for i in {1..30}; do
            if kubectl get nodes --request-timeout=10s >/dev/null 2>&1; then
              echo "K3s API server is ready for kubectl!"
              break
            fi
            echo "Attempt $i: kubectl not ready yet, waiting..."
            sleep 10
          done
      
      - name: Create secrets directory and files
        run: |
          mkdir -p k8s/base/secrets
          
          cat > k8s/base/secrets/db.env << EOF
          MYSQL_ROOT_PASSWORD=root
          MYSQL_DATABASE=BucketList
          MYSQL_DATABASE_PASSWORD=root
          EOF
          
          echo "Created secrets directory and db.env file"
          ls -la k8s/base/secrets/

      - name: Deploy to K3s cluster
        run: |
          sed -i "s|:latest|:${{ env.IMAGE_TAG }}|g" k8s/overlays/testing/kustomization.yaml
          sed -i "s|CONTROL_PLANE_IP|${{ env.CONTROL_PLANE_IP }}|g" k8s/overlays/testing/ingress-patch.yaml

          ls -R k8s/overlays/testing/

          kubectl apply -k k8s/overlays/testing/

          kubectl get pods
          kubectl get services  
          kubectl get ingress

      - name: Cleanup sensitive files
        if: always()
        run: |
          rm -f ~/.ssh/k3s-key
          rm -f private-key.pem
          rm -f terraform_outputs.json